
import { Hono } from "hono";
import { prisma } from "../prisma";
import { Gender } from "../../generated/prisma/enums";
import { Role } from "../../generated/prisma/enums"
import * as argon2 from "argon2";
import jwt from "jsonwebtoken";
import { authMiddleware } from '../middleware/auth';

export const mem = new Hono()

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error("JWT_SECRET is not defined");
}

const apiResponse = (
  c: any,
  status: number,
  message: string,
  data: any = null,
  error: any = null
) => {
  return c.json(
    {
      status,
      message,
      data,
      error,
    },
    200
  )
}



mem.get("/", authMiddleware, async (c) => {
  try {
   const members = await prisma.member.findMany({
  select: {
    id: true,
    email: true,
    username: true,
    gender: true,
  },
})
    return apiResponse(c, 200, "Get members success", members)
  } catch (err) {
    return apiResponse(c, 500, "Failed to fetch members", null, err)
  }
})


mem.get("/:id",authMiddleware , async (c) => {
  const id = Number(c.req.param("id"))
 
  try {
    const member = await prisma.member.findUnique({
  where: { id },
  select: {
    id: true,
    email: true,
    username: true,
    gender: true,
  },
});

    if (!member) {
      return apiResponse(c, 404, "Member not found")
    }

    return apiResponse(c, 200, "Get member success", member)
  } catch (err) {
    return apiResponse(c, 500, "Failed to fetch member", null, err)
  }
})

mem.post("/login", async (c) => {
  const body = await c.req.json();
  const { email, password } = body;
  if (!email || !password) {
    return apiResponse(c, 400, "Missing email or password");
  }
  try {
    const member = await prisma.member.findUnique({
      where: { email },
    });
    if (!member) {
      return apiResponse(c, 401, "Invalid email ");
    }
    const match = await argon2.verify(member.password, password);
    if (!match) {
      return apiResponse(c, 401, "Invalid password");
    }
    const token = jwt.sign(
      { memberId: member.id, email: member.email },
      JWT_SECRET,
      { expiresIn: "1d", algorithm: "HS256" }
    );
    return apiResponse(c, 200, "Login success", {
    token
  });
  } catch (err) {
    return apiResponse(c, 500, "Login failed", null, err);
  }
});

mem.post("/register",  async (c) => {
  const body = await c.req.json();
  const { email, username, password, gender,role } = body;

  if (!email || !username || !password) {
    return apiResponse(c, 400, "Missing required fields");
  }

  if (gender && !Object.values(Gender).includes(gender)) {
    return apiResponse(c, 400, "Invalid gender");
  }
 if (role && !Object.values(Role).includes(role)) {
    return apiResponse(c, 400, "Invalid gender");
  }
  try {
    
    const hashedPassword = await argon2.hash(password, { type: argon2.argon2id });

    const member = await prisma.member.create({
      data: {
        email,
        username,
        password: hashedPassword,
        gender,
        role
      },
    });

    return apiResponse(c, 201, "Register success", {
  id: member.id,
  email: member.email,
});
  } catch (err) {
    return apiResponse(c, 500, "Register failed", null, err);
  }
});


mem.put("/:id",authMiddleware, async (c) => {
  const id = Number(c.req.param("id"));
  const body = await c.req.json();
  const { email, username, password, gender } = body;

  if (gender && !Object.values(Gender).includes(gender)) {
    return apiResponse(c, 400, "Invalid gender");
  }

  try {
    const exists = await prisma.member.findUnique({ where: { id } });
    if (!exists) {
      return apiResponse(c, 404, "Member not found");
    }

  
    let hashedPassword = exists.password;
    if (password) {
      hashedPassword = await argon2.hash(password, { type: argon2.argon2id });
    }

    const member = await prisma.member.update({
      where: { id },
      data: {
        email,
        username,
        password: hashedPassword,
        gender,
      },
    });

    return apiResponse(c, 200, "Update member success", member);
  } catch (err) {
    return apiResponse(c, 500, "Update member failed", null, err);
  }
});


mem.delete("/:id",authMiddleware, async (c) => {
  const id = Number(c.req.param("id"))

  try {
    const exists = await prisma.member.findUnique({ where: { id } })
    if (!exists) {
      return apiResponse(c, 404, "Member not found")
    }

    await prisma.member.delete({
      where: { id },
    })

    return apiResponse(c, 200, "Member deleted")
  } catch (err) {
    return apiResponse(c, 500, "Delete member failed", null, err)
  }
})
